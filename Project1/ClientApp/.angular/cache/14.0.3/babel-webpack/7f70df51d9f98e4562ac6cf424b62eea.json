{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _wrapAsyncGenerator from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncIterator from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _asyncGeneratorDelegate from \"C:/Users/lbsousa/Angular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\n\nvar _parts, _type, _size, _endings;\n\nlet _Symbol$toStringTag, _Symbol$hasInstance;\n\n/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\nimport './streams.cjs'; // 64 KiB (same size chrome slice theirs blob into Uint8array's)\n\nconst POOL_SIZE = 65536;\n/** @param {(Blob | Uint8Array)[]} parts */\n\nfunction toIterator(_x) {\n  return _toIterator.apply(this, arguments);\n}\n\nfunction _toIterator() {\n  _toIterator = _wrapAsyncGenerator(function* (parts, clone = true) {\n    for (const part of parts) {\n      if ('stream' in part) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(\n        /** @type {AsyncIterableIterator<Uint8Array>} */\n        part.stream()), _awaitAsyncGenerator);\n      } else if (ArrayBuffer.isView(part)) {\n        if (clone) {\n          let position = part.byteOffset;\n          const end = part.byteOffset + part.byteLength;\n\n          while (position !== end) {\n            const size = Math.min(end - position, POOL_SIZE);\n            const chunk = part.buffer.slice(position, position + size);\n            position += chunk.byteLength;\n            yield new Uint8Array(chunk);\n          }\n        } else {\n          yield part;\n        }\n        /* c8 ignore next 10 */\n\n      } else {\n        // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n        let position = 0,\n            b =\n        /** @type {Blob} */\n        part;\n\n        while (position !== b.size) {\n          const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n          const buffer = yield _awaitAsyncGenerator(chunk.arrayBuffer());\n          position += buffer.byteLength;\n          yield new Uint8Array(buffer);\n        }\n      }\n    }\n  });\n  return _toIterator.apply(this, arguments);\n}\n\nconst _Blob = (_parts = /*#__PURE__*/new WeakMap(), _type = /*#__PURE__*/new WeakMap(), _size = /*#__PURE__*/new WeakMap(), _endings = /*#__PURE__*/new WeakMap(), _Symbol$toStringTag = Symbol.toStringTag, _Symbol$hasInstance = Symbol.hasInstance, class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor(blobParts = [], options = {}) {\n    _classPrivateFieldInitSpec(this, _parts, {\n      writable: true,\n      value: []\n    });\n\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: ''\n    });\n\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: 0\n    });\n\n    _classPrivateFieldInitSpec(this, _endings, {\n      writable: true,\n      value: 'transparent'\n    });\n\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.');\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.');\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.');\n    }\n\n    if (options === null) options = {};\n    const encoder = new TextEncoder();\n\n    for (const element of blobParts) {\n      let part;\n\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0));\n      } else if (element instanceof Blob) {\n        part = element;\n      } else {\n        part = encoder.encode(`${element}`);\n      }\n\n      _classPrivateFieldSet(this, _size, _classPrivateFieldGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n\n      _classPrivateFieldGet(this, _parts).push(part);\n    }\n\n    _classPrivateFieldSet(this, _endings, `${options.endings === undefined ? 'transparent' : options.endings}`);\n\n    const type = options.type === undefined ? '' : String(options.type);\n\n    _classPrivateFieldSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : '');\n  }\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n\n\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n\n\n  get type() {\n    return _classPrivateFieldGet(this, _type);\n  }\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n\n\n  text() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // More optimized than using this.arrayBuffer()\n      // that requires twice as much ram\n      const decoder = new TextDecoder();\n      let str = '';\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(toIterator(_classPrivateFieldGet(_this, _parts), false)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const part = _step.value;\n          str += decoder.decode(part, {\n            stream: true\n          });\n        } // Remaining\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      str += decoder.decode();\n      return str;\n    })();\n  }\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  arrayBuffer() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Easier way... Just a unnecessary overhead\n      // const view = new Uint8Array(this.size);\n      // await this.stream().getReader({mode: 'byob'}).read(view);\n      // return view.buffer;\n      const data = new Uint8Array(_this2.size);\n      let offset = 0;\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(toIterator(_classPrivateFieldGet(_this2, _parts), false)), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n          const chunk = _step2.value;\n          data.set(chunk, offset);\n          offset += chunk.length;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            yield _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return data.buffer;\n    })();\n  }\n\n  stream() {\n    const it = toIterator(_classPrivateFieldGet(this, _parts), true);\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n\n      pull(ctrl) {\n        return _asyncToGenerator(function* () {\n          const chunk = yield it.next();\n          chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n        })();\n      },\n\n      cancel() {\n        return _asyncToGenerator(function* () {\n          yield it.return();\n        })();\n      }\n\n    });\n  }\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n\n\n  slice(start = 0, end = this.size, type = '') {\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n\n    const parts = _classPrivateFieldGet(this, _parts);\n\n    const blobParts = [];\n    let added = 0;\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break;\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        let chunk;\n\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.byteLength;\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.size;\n        }\n\n        relativeEnd -= size;\n        blobParts.push(chunk);\n        relativeStart = 0; // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], {\n      type: String(type).toLowerCase()\n    });\n\n    _classPrivateFieldSet(blob, _size, span);\n\n    _classPrivateFieldSet(blob, _parts, blobParts);\n\n    return blob;\n  }\n\n  get [_Symbol$toStringTag]() {\n    return 'Blob';\n  }\n\n  static [_Symbol$hasInstance](object) {\n    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n\n});\n\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n/** @type {typeof globalThis.Blob} */\n\nexport const Blob = _Blob;\nexport default Blob;","map":{"version":3,"names":["POOL_SIZE","toIterator","parts","clone","part","stream","ArrayBuffer","isView","position","byteOffset","end","byteLength","size","Math","min","chunk","buffer","slice","Uint8Array","b","arrayBuffer","_Blob","Symbol","toStringTag","hasInstance","Blob","constructor","blobParts","options","TypeError","iterator","encoder","TextEncoder","element","encode","push","endings","undefined","type","String","test","text","decoder","TextDecoder","str","decode","data","offset","set","length","it","globalThis","ReadableStream","pull","ctrl","next","done","close","enqueue","value","cancel","return","start","relativeStart","max","relativeEnd","span","added","subarray","blob","toLowerCase","object","Object","defineProperties","prototype","enumerable"],"sources":["C:/Users/lbsousa/Angular/Project1/node_modules/fetch-blob/index.js"],"sourcesContent":["/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}